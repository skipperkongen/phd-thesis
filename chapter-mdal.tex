% !TEX root = ./thesis.tex
\chapter{Declarative Multi-scale Abstraction of Large Graphs}

% Define clear usecase
% - Zoomable visualizations of large social networks

We want to:
\begin{itemize}
\item Model all data as graphs, because graphs are general (they subsume spatial, temporal and social data). 
\item Visualize graphs at different focal points and levels of abstraction, i.e. zoom and pan
\item Share beautiful visualizations with the world in a scalable manor
\item Support and design a declarative language for creating zoomable graph visualizations
\end{itemize}

We need:
\begin{itemize}
\item Efficient, effective and easy-to-use way to specify visualizations, e.g. a declarative language
\item Efficient and effective ways to compute visualizations, i.e. algorithms and system implementations (perhaps on top of Giraph or Neo4J)
\item Efficient and effective ways to serve visualizations, i.e. a scalable query model (e.g. pyramid model)
\end{itemize}

We assume that there:

\begin{itemize}
\item Exists methods for translating any data into nodes and edges form; we will give examples
\item Exists methods for embedding nodes and edges in the plane, i.e. computing two-dimensional coordinates for nodes and edges
\end{itemize}

For this to work, we at least need to:
\begin{itemize}
\item Define a notion of \emph{resolution} or \emph{scale} for graphs; it is sufficient to define a unit for the two-dimensional coordinate system, e.g. meters
\item Define a query model for graph views, e.g. the pyramid model because it is scalable
\item Define constraints for single graph views, i.e. density constraint (visibility) and distance constraint (proximity)
\item Define cross view constraints, i.e. zoom and pan constraints and graph minor constraints.
\item Enable ways to define metrics for evaluating graph constraints, i.e. a way to define an information density metric (see Woodruff et al.~\cite{woodruff1998constant}) and distance metric.
\item Define valid transformation functions for turning one graph into another graph, i.e. a graph minor step.
\item Define objective function, i.e. scale-dependent ranking of nodes and edges
\end{itemize}

To support a declarative language, we need to:

\begin{itemize}
\item Define the language syntax
\item Define the language semantics
\end{itemize}

% Motivation

\section{Introduction}

\section{Multi-scale Graph Abstraction}
% the problem
\subsection{Constraints and Metrics}
\subsubsection{Density Constraint}
\paragraph{Metrics}
\subsubsection{Proximity Constraint}
\paragraph{Metrics}
\subsubsection{Graph Minor Constraint}

\subsection{Node ranking}
\subsubsection{Static Ranking}
\subsubsection{PageRank Weighted Ranking}

\section{GAL: Graph Abstraction Language}
\subsection{Syntax}
\subsection{Semantics}

\section{Processing GAL}
\subsection{Bulk Synchronous Parallel Model (BSP model)}
% look at pregel, https://hama.apache.org/, https://giraph.apache.org/
% comparison of systems: http://www.ibm.com/developerworks/library/os-giraph/
% - Apache Hama Ñ focuses on general BSP computations, so it is not only for graphs.
\subsection{Compiling GAL Queries to BSP jobs}

\section{Experimental Evaluation}

\section{Related Work}

\section{Conclusion}